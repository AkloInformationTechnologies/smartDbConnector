// Generated by CoffeeScript 1.6.2
var EPOCH_DATE, MAX, NULL, TYPE, guidParser, id, type, typeByName;

guidParser = require('./guid-parser');

NULL = (1 << 16) - 1;

EPOCH_DATE = new Date(1900, 0, 1);

MAX = (1 << 16) - 1;

TYPE = {
  0x1F: {
    type: 'NULL',
    name: 'Null'
  },
  0x30: {
    type: 'INT1',
    name: 'TinyInt',
    declaration: function(parameter) {
      return 'tinyint';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.IntN.id);
      buffer.writeUInt8(1);
      if (parameter.value != null) {
        buffer.writeUInt8(1);
        return buffer.writeInt8(parseInt(parameter.value));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x32: {
    type: 'BIT',
    name: 'Bit',
    declaration: function(parameter) {
      return 'bit';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.BitN.id);
      buffer.writeUInt8(1);
      if (typeof parameter.value === 'undefined' || parameter.value === null) {
        return buffer.writeUInt8(0);
      } else {
        buffer.writeUInt8(1);
        return buffer.writeUInt8(parameter.value ? 1 : 0);
      }
    }
  },
  0x34: {
    type: 'INT2',
    name: 'SmallInt',
    declaration: function(parameter) {
      return 'smallint';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.IntN.id);
      buffer.writeUInt8(2);
      if (parameter.value != null) {
        buffer.writeUInt8(2);
        return buffer.writeInt16LE(parseInt(parameter.value));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x38: {
    type: 'INT4',
    name: 'Int',
    declaration: function(parameter) {
      return 'int';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.IntN.id);
      buffer.writeUInt8(4);
      if (parameter.value != null) {
        buffer.writeUInt8(4);
        return buffer.writeInt32LE(parseInt(parameter.value));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x3A: {
    type: 'DATETIM4',
    name: 'SmallDateTime',
    declaration: function(parameter) {
      return 'smalldatetime';
    },
    writeParameterData: function(buffer, parameter) {
      var days, minutes;

      buffer.writeUInt8(typeByName.DateTimeN.id);
      buffer.writeUInt8(4);
      if (parameter.value != null) {
        days = (parameter.value.getTime() - EPOCH_DATE.getTime()) / (1000 * 60 * 60 * 24);
        days = Math.floor(days);
        minutes = (parameter.value.getHours() * 60) + parameter.value.getMinutes();
        buffer.writeUInt8(4);
        buffer.writeUInt16LE(days);
        return buffer.writeUInt16LE(minutes);
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x3B: {
    type: 'FLT4',
    name: 'Real',
    declaration: function(parameter) {
      return 'real';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.FloatN.id);
      buffer.writeUInt8(4);
      if (parameter.value != null) {
        buffer.writeUInt8(4);
        return buffer.writeFloatLE(parseFloat(parameter.value));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x3C: {
    type: 'MONEY',
    name: 'Money'
  },
  0x3D: {
    type: 'DATETIME',
    name: 'DateTime',
    declaration: function(parameter) {
      return 'datetime';
    },
    writeParameterData: function(buffer, parameter) {
      var days, milliseconds, seconds, threeHundredthsOfSecond;

      buffer.writeUInt8(typeByName.DateTimeN.id);
      buffer.writeUInt8(8);
      if (parameter.value != null) {
        days = (parameter.value.getTime() - EPOCH_DATE.getTime()) / (1000 * 60 * 60 * 24);
        days = Math.floor(days);
        seconds = parameter.value.getHours() * 60 * 60;
        seconds += parameter.value.getMinutes() * 60;
        seconds += parameter.value.getSeconds();
        milliseconds = (seconds * 1000) + parameter.value.getMilliseconds();
        threeHundredthsOfSecond = milliseconds / (3 + (1 / 3));
        threeHundredthsOfSecond = Math.floor(threeHundredthsOfSecond);
        buffer.writeUInt8(8);
        buffer.writeUInt32LE(days);
        return buffer.writeUInt32LE(threeHundredthsOfSecond);
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x3E: {
    type: 'FLT8',
    name: 'Float',
    declaration: function(parameter) {
      return 'float';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.FloatN.id);
      buffer.writeUInt8(8);
      if (parameter.value != null) {
        buffer.writeUInt8(8);
        return buffer.writeDoubleLE(parseFloat(parameter.value));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x7A: {
    type: 'MONEY4',
    name: 'SmallMoney'
  },
  0x7F: {
    type: 'INT8',
    name: 'BigInt',
    declaration: function(parameter) {
      return 'bigint';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.IntN.id);
      buffer.writeUInt8(8);
      if (parameter.value) {
        buffer.writeUInt8(8);
        if (parseInt(parameter.value) > 0x100000000) {
          buffer.writeUInt32LE(parseInt(parameter.value) % 0x100000000);
        } else {
          buffer.writeInt32LE(parseInt(parameter.value) % 0x100000000);
        }
        return buffer.writeInt32LE(Math.floor(parseInt(parameter.value) / 0x100000000));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x22: {
    type: 'IMAGE',
    name: 'Image',
    hasTableName: true,
    hasTextPointerAndTimestamp: true,
    dataLengthLength: 4
  },
  0x23: {
    type: 'TEXT',
    name: 'Text',
    hasCollation: true,
    hasTableName: true,
    hasTextPointerAndTimestamp: true,
    dataLengthLength: 4,
    declaration: function(parameter) {
      return 'text';
    },
    writeParameterData: function(buffer, parameter) {
      var length;

      if (parameter.length) {
        length = parameter.length;
      } else if (parameter.value != null) {
        length = parameter.value.toString().length;
      } else {
        length = -1;
      }
      buffer.writeUInt8(typeByName.Text.id);
      buffer.writeInt32LE(length);
      buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));
      if (parameter.value != null) {
        buffer.writeInt32LE(length);
        return buffer.writeString(parameter.value.toString(), 'ascii');
      } else {
        return buffer.writeInt32LE(length);
      }
    }
  },
  0x24: {
    type: 'GUIDN',
    name: 'UniqueIdentifierN',
    dataLengthLength: 1,
    declaration: function(parameter) {
      return 'uniqueidentifier';
    },
    writeParameterData: function(buffer, parameter) {
      buffer.writeUInt8(typeByName.UniqueIdentifierN.id);
      buffer.writeUInt8(0x10);
      if (parameter.value != null) {
        buffer.writeUInt8(0x10);
        return buffer.writeBuffer(new Buffer(guidParser.guidToArray(parameter.value)));
      } else {
        return buffer.writeUInt8(0);
      }
    }
  },
  0x26: {
    type: 'INTN',
    name: 'IntN',
    dataLengthLength: 1
  },
  0x63: {
    type: 'NTEXT',
    name: 'NText',
    hasCollation: true,
    hasTableName: true,
    hasTextPointerAndTimestamp: true,
    dataLengthLength: 4
  },
  0x68: {
    type: 'BITN',
    name: 'BitN',
    dataLengthLength: 1
  },
  0x6A: {
    type: 'DECIMALN',
    name: 'DecimalN',
    dataLengthLength: 1,
    hasPrecision: true,
    hasScale: true
  },
  0x6C: {
    type: 'NUMERICN',
    name: 'NumericN',
    dataLengthLength: 1,
    hasPrecision: true,
    hasScale: true
  },
  0x6D: {
    type: 'FLTN',
    name: 'FloatN',
    dataLengthLength: 1
  },
  0x6E: {
    type: 'MONEYN',
    name: 'MoneyN',
    dataLengthLength: 1
  },
  0x6F: {
    type: 'DATETIMN',
    name: 'DateTimeN',
    dataLengthLength: 1
  },
  0xA5: {
    type: 'BIGVARBIN',
    name: 'VarBinary',
    dataLengthLength: 2
  },
  0xA7: {
    type: 'BIGVARCHR',
    name: 'VarChar',
    hasCollation: true,
    dataLengthLength: 2,
    maximumLength: 8000,
    declaration: function(parameter) {
      var length;

      if (parameter.length) {
        length = parameter.length;
      } else if (parameter.value != null) {
        length = parameter.value.toString().length;
      } else {
        length = this.maximumLength;
      }
      if (length <= this.maximumLength) {
        return "varchar(" + this.maximumLength + ")";
      } else {
        return "varchar(max)";
      }
    },
    writeParameterData: function(buffer, parameter) {
      var length;

      if (parameter.length) {
        length = parameter.length;
      } else if (parameter.value != null) {
        length = parameter.value.toString().length;
      } else {
        length = this.maximumLength;
      }
      buffer.writeUInt8(this.id);
      if (length <= this.maximumLength) {
        buffer.writeUInt16LE(this.maximumLength);
      } else {
        buffer.writeUInt16LE(MAX);
      }
      buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));
      if (parameter.value != null) {
        if (length <= this.maximumLength) {
          buffer.writeUInt16LE(length);
          return buffer.writeString(parameter.value.toString(), 'ascii');
        } else {
          buffer.writeUInt64LE(length);
          buffer.writeUInt32LE(length);
          buffer.writeString(parameter.value.toString(), 'ascii');
          return buffer.writeUInt32LE(0);
        }
      } else {
        return buffer.writeUInt16LE(NULL);
      }
    }
  },
  0xAD: {
    type: 'BIGBinary',
    name: 'Binary',
    dataLengthLength: 2
  },
  0xAF: {
    type: 'BIGCHAR',
    name: 'Char',
    hasCollation: true,
    dataLengthLength: 2
  },
  0xE7: {
    type: 'NVARCHAR',
    name: 'NVarChar',
    hasCollation: true,
    dataLengthLength: 2,
    maximumLength: 4000,
    declaration: function(parameter) {
      var length;

      if (parameter.length) {
        length = 2 * parameter.length;
      } else if (parameter.value != null) {
        length = 2 * parameter.value.toString().length;
      } else {
        length = this.maximumLength;
      }
      if (length <= this.maximumLength) {
        return "nvarchar(" + this.maximumLength + ")";
      } else {
        return "nvarchar(max)";
      }
    },
    writeParameterData: function(buffer, parameter) {
      var length;

      if (parameter.length) {
        length = 2 * parameter.length;
      } else if (parameter.value != null) {
        length = 2 * parameter.value.toString().length;
      } else {
        length = this.maximumLength;
      }
      buffer.writeUInt8(this.id);
      if (length <= this.maximumLength) {
        buffer.writeUInt16LE(this.maximumLength);
      } else {
        buffer.writeUInt16LE(MAX);
      }
      buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));
      if (parameter.value != null) {
        if (length <= this.maximumLength) {
          buffer.writeUInt16LE(length);
          return buffer.writeString(parameter.value.toString(), 'ucs2');
        } else {
          buffer.writeUInt64LE(length);
          buffer.writeUInt32LE(length);
          buffer.writeString(parameter.value.toString(), 'ucs2');
          return buffer.writeUInt32LE(0);
        }
      } else {
        return buffer.writeUInt16LE(NULL);
      }
    }
  },
  0xEF: {
    type: 'NCHAR',
    name: 'NChar',
    hasCollation: true,
    dataLengthLength: 2
  },
  0xF1: {
    type: 'XML',
    name: 'Xml',
    hasSchemaPresent: true
  }
};

/*
  DECIMALTYPE:          0x37  # Decimal (legacy support)
  NUMERICTYPE:          0x3F  # Numeric (legacy support)
  DATENTYPE:            0x28  # (introduced in TDS 7.3)
  TIMENTYPE:            0x29  # (introduced in TDS 7.3)
  DATETIME2NTYPE:       0x2A  # (introduced in TDS 7.3)
  DATETIMEOFFSETNTYPE:  0x2B  # (introduced in TDS 7.3)
  CHARTYPE:             0x2F  # Char (legacy support)
  VARCHARTYPE:          0x27  # VarChar (legacy support)
  BINARYTYPE:           0x2D  # Binary (legacy support)
  VARBINARYTYPE:        0x25  # VarBinary (legacy support)

  UDTTYPE:              0xF0  # CLR-UDT (introduced in TDS 7.2)

  SSVARIANTTYPE:        0x62  # Sql_Variant (introduced in TDS 7.2)
*/


typeByName = {};

for (id in TYPE) {
  type = TYPE[id];
  type.id = parseInt(id, 10);
  typeByName[type.name] = type;
}

exports.TYPE = TYPE;

exports.typeByName = typeByName;
