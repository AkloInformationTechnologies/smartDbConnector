// Generated by CoffeeScript 1.6.2
var Connection, DEFAULT_CANCEL_TIMEOUT, DEFAULT_CLIENT_REQUEST_TIMEOUT, DEFAULT_CONNECT_TIMEOUT, DEFAULT_PACKET_SIZE, DEFAULT_PORT, DEFAULT_TDS_VERSION, DEFAULT_TEXTSIZE, Debug, EventEmitter, ISOLATION_LEVEL, KEEP_ALIVE_INITIAL_DELAY, Login7Payload, MessageIO, PreloginPayload, Request, RpcRequestPayload, Socket, SqlBatchPayload, TYPE, TokenStreamParser, Transaction, crypto, instanceLookup, tls,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

require('./buffertools');

Debug = require('./debug');

EventEmitter = require('events').EventEmitter;

instanceLookup = require('./instance-lookup').instanceLookup;

TYPE = require('./packet').TYPE;

PreloginPayload = require('./prelogin-payload');

Login7Payload = require('./login7-payload');

Request = require('./request');

RpcRequestPayload = require('./rpcrequest-payload');

SqlBatchPayload = require('./sqlbatch-payload');

MessageIO = require('./message-io');

Socket = require('net').Socket;

TokenStreamParser = require('./token/token-stream-parser').Parser;

Transaction = require('./transaction').Transaction;

ISOLATION_LEVEL = require('./transaction').ISOLATION_LEVEL;

crypto = require('crypto');

tls = require('tls');

KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;

DEFAULT_CONNECT_TIMEOUT = 15 * 1000;

DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;

DEFAULT_CANCEL_TIMEOUT = 5 * 1000;

DEFAULT_PACKET_SIZE = 4 * 1024;

DEFAULT_TEXTSIZE = '2147483647';

DEFAULT_PORT = 1433;

DEFAULT_TDS_VERSION = '7_2';

Connection = (function(_super) {
  __extends(Connection, _super);

  Connection.prototype.STATE = {
    CONNECTING: {
      name: 'Connecting',
      enter: function() {
        return this.initialiseConnection();
      },
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        socketConnect: function() {
          this.sendPreLogin();
          return this.transitionTo(this.STATE.SENT_PRELOGIN);
        }
      }
    },
    SENT_PRELOGIN: {
      name: 'SentPrelogin',
      enter: function() {
        return this.emptyMessageBuffer();
      },
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        data: function(data) {
          return this.addToMessageBuffer(data);
        },
        message: function() {
          return this.processPreLoginResponse();
        },
        noTls: function() {
          this.sendLogin7Packet();
          return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
        },
        tls: function() {
          this.initiateTlsSslHandshake();
          this.sendLogin7Packet();
          return this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
        }
      }
    },
    SENT_TLSSSLNEGOTIATION: {
      name: 'SentTLSSSLNegotiation',
      enter: function() {},
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        data: function(data) {
          return this.securePair.encrypted.write(data);
        },
        tlsNegotiated: function() {
          return this.tlsNegotiationComplete = true;
        },
        message: function() {
          if (this.tlsNegotiationComplete) {
            return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
          } else {

          }
        }
      }
    },
    SENT_LOGIN7_WITH_STANDARD_LOGIN: {
      name: 'SentLogin7WithStandardLogin',
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        data: function(data) {
          return this.sendDataToTokenStreamParser(data);
        },
        loggedIn: function() {
          return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
        },
        loginFailed: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        message: function() {
          return this.processLogin7Response();
        }
      }
    },
    LOGGED_IN_SENDING_INITIAL_SQL: {
      name: 'LoggedInSendingInitialSql',
      enter: function() {
        return this.sendInitialSql();
      },
      events: {
        connectTimeout: function() {
          return this.transitionTo(this.STATE.FINAL);
        },
        data: function(data) {
          return this.sendDataToTokenStreamParser(data);
        },
        message: function(error) {
          this.transitionTo(this.STATE.LOGGED_IN);
          return this.processedInitialSql();
        }
      }
    },
    LOGGED_IN: {
      name: 'LoggedIn',
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_CLIENT_REQUEST: {
      name: 'SentClientRequest',
      events: {
        socketError: function(error) {
          return this.transitionTo(this.STATE.FINAL);
        },
        data: function(data) {
          return this.sendDataToTokenStreamParser(data);
        },
        message: function() {
          var sqlRequest;

          this.transitionTo(this.STATE.LOGGED_IN);
          sqlRequest = this.request;
          this.request = void 0;
          return sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
        }
      }
    },
    FINAL: {
      name: 'Final',
      enter: function() {
        return this.cleanupConnection();
      },
      events: {
        loginFailed: function() {},
        connectTimeout: function() {},
        message: function() {},
        socketError: function() {}
      }
    }
  };

  function Connection(config) {
    this.config = config;
    this.reset = __bind(this.reset, this);
    this.socketClose = __bind(this.socketClose, this);
    this.socketConnect = __bind(this.socketConnect, this);
    this.socketError = __bind(this.socketError, this);
    this.connectTimeout = __bind(this.connectTimeout, this);
    this.defaultConfig();
    this.createDebug();
    this.createTokenStreamParser();
    this.transactions = [];
    this.transactionDescriptors = [new Buffer([0, 0, 0, 0, 0, 0, 0, 0])];
    this.transitionTo(this.STATE.CONNECTING);
  }

  Connection.prototype.close = function() {
    return this.transitionTo(this.STATE.FINAL);
  };

  Connection.prototype.initialiseConnection = function() {
    this.connect();
    return this.createConnectTimer();
  };

  Connection.prototype.cleanupConnection = function() {
    if (!this.closed) {
      this.clearConnectTimer();
      this.closeConnection();
      this.emit('end');
      return this.closed = true;
    }
  };

  Connection.prototype.defaultConfig = function() {
    var _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _base9;

    (_base = this.config).options || (_base.options = {});
    (_base1 = this.config.options).textsize || (_base1.textsize = DEFAULT_TEXTSIZE);
    (_base2 = this.config.options).connectTimeout || (_base2.connectTimeout = DEFAULT_CONNECT_TIMEOUT);
    (_base3 = this.config.options).requestTimeout || (_base3.requestTimeout = DEFAULT_CLIENT_REQUEST_TIMEOUT);
    (_base4 = this.config.options).cancelTimeout || (_base4.cancelTimeout = DEFAULT_CANCEL_TIMEOUT);
    (_base5 = this.config.options).packetSize || (_base5.packetSize = DEFAULT_PACKET_SIZE);
    (_base6 = this.config.options).tdsVersion || (_base6.tdsVersion = DEFAULT_TDS_VERSION);
    (_base7 = this.config.options).isolationLevel || (_base7.isolationLevel = ISOLATION_LEVEL.READ_UNCOMMITTED);
    (_base8 = this.config.options).encrypt || (_base8.encrypt = false);
    (_base9 = this.config.options).cryptoCredentialsDetails || (_base9.cryptoCredentialsDetails = {});
    if (!this.config.options.port && !this.config.options.instanceName) {
      return this.config.options.port = DEFAULT_PORT;
    } else if (this.config.options.port && this.config.options.instanceName) {
      throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
    }
  };

  Connection.prototype.createDebug = function() {
    var _this = this;

    this.debug = new Debug(this.config.options.debug);
    return this.debug.on('debug', function(message) {
      return _this.emit('debug', message);
    });
  };

  Connection.prototype.createTokenStreamParser = function() {
    var _this = this;

    this.tokenStreamParser = new TokenStreamParser(this.debug, void 0, this.config.options.tdsVersion);
    this.tokenStreamParser.on('infoMessage', function(token) {
      return _this.emit('infoMessage', token);
    });
    this.tokenStreamParser.on('errorMessage', function(token) {
      _this.emit('errorMessage', token);
      if (_this.request) {
        return _this.request.error = token.message;
      }
    });
    this.tokenStreamParser.on('databaseChange', function(token) {
      return _this.emit('databaseChange', token.newValue);
    });
    this.tokenStreamParser.on('languageChange', function(token) {
      return _this.emit('languageChange', token.newValue);
    });
    this.tokenStreamParser.on('charsetChange', function(token) {
      return _this.emit('charsetChange', token.newValue);
    });
    this.tokenStreamParser.on('loginack', function(token) {
      return _this.loggedIn = true;
    });
    this.tokenStreamParser.on('packetSizeChange', function(token) {
      return _this.messageIo.packetSize(token.newValue);
    });
    this.tokenStreamParser.on('beginTransaction', function(token) {
      return _this.transactionDescriptors.push(token.newValue);
    });
    this.tokenStreamParser.on('commitTransaction', function(token) {
      return _this.transactionDescriptors.pop();
    });
    this.tokenStreamParser.on('rollbackTransaction', function(token) {
      return _this.transactionDescriptors.pop();
    });
    this.tokenStreamParser.on('columnMetadata', function(token) {
      if (_this.request) {
        return _this.request.emit('columnMetadata', token.columns);
      } else {
        throw new Error("Received 'columnMetadata' when no sqlRequest is in progress");
      }
    });
    this.tokenStreamParser.on('order', function(token) {
      if (_this.request) {
        return _this.request.emit('order', token.orderColumns);
      } else {
        throw new Error("Received 'order' when no sqlRequest is in progress");
      }
    });
    this.tokenStreamParser.on('row', function(token) {
      if (_this.request) {
        if (_this.config.options.rowCollectionOnRequestCompletion || _this.config.options.rowCollectionOnDone) {
          _this.request.rows.push(token.columns);
        }
        return _this.request.emit('row', token.columns);
      } else {
        throw new Error("Received 'row' when no sqlRequest is in progress");
      }
    });
    this.tokenStreamParser.on('returnStatus', function(token) {
      if (_this.request) {
        return _this.procReturnStatusValue = token.value;
      }
    });
    this.tokenStreamParser.on('returnValue', function(token) {
      if (_this.request) {
        return _this.request.emit('returnValue', token.paramName, token.value, token.metadata);
      }
    });
    this.tokenStreamParser.on('doneProc', function(token) {
      if (_this.request) {
        _this.request.emit('doneProc', token.rowCount, token.more, _this.procReturnStatusValue, _this.request.rows);
        _this.procReturnStatusValue = void 0;
        if (token.rowCount !== void 0) {
          _this.request.rowCount += token.rowCount;
        }
        if (_this.config.options.rowCollectionOnDone) {
          return _this.request.rows = [];
        }
      }
    });
    this.tokenStreamParser.on('doneInProc', function(token) {
      if (_this.request) {
        _this.request.emit('doneInProc', token.rowCount, token.more, _this.request.rows);
        if (token.rowCount !== void 0) {
          _this.request.rowCount += token.rowCount;
        }
        if (_this.config.options.rowCollectionOnDone) {
          return _this.request.rows = [];
        }
      }
    });
    this.tokenStreamParser.on('done', function(token) {
      if (_this.request) {
        _this.request.emit('done', token.rowCount, token.more, _this.request.rows);
        if (token.rowCount !== void 0) {
          _this.request.rowCount += token.rowCount;
        }
        if (_this.config.options.rowCollectionOnDone) {
          return _this.request.rows = [];
        }
      }
    });
    return this.tokenStreamParser.on('resetConnection', function(token) {
      return _this.emit('resetConnection');
    });
  };

  Connection.prototype.connect = function() {
    var _this = this;

    if (this.config.options.port) {
      return this.connectOnPort(this.config.options.port);
    } else {
      return instanceLookup(this.config.server, this.config.options.instanceName, function(err, port) {
        if (err) {
          throw new Error(err);
        } else {
          return _this.connectOnPort(port);
        }
      });
    }
  };

  Connection.prototype.connectOnPort = function(port) {
    var _this = this;

    this.socket = new Socket({});
    this.socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
    this.socket.connect(port, this.config.server);
    this.socket.on('error', this.socketError);
    this.socket.on('connect', this.socketConnect);
    this.socket.on('close', this.socketClose);
    this.socket.on('end', this.socketClose);
    this.messageIo = new MessageIO(this.socket, this.config.options.packetSize, this.debug);
    this.messageIo.on('data', function(data) {
      return _this.dispatchEvent('data', data);
    });
    return this.messageIo.on('message', function() {
      return _this.dispatchEvent('message');
    });
  };

  Connection.prototype.closeConnection = function() {
    return this.socket.destroy();
  };

  Connection.prototype.createConnectTimer = function() {
    return this.connectTimer = setTimeout(this.connectTimeout, this.config.options.connectTimeout);
  };

  Connection.prototype.connectTimeout = function() {
    var message;

    message = "timeout : failed to connect to " + this.config.server + ":" + this.config.options.port + " in " + this.config.options.connectTimeout + "ms";
    this.debug.log(message);
    this.emit('connect', message);
    this.connectTimer = void 0;
    return this.dispatchEvent('connectTimeout');
  };

  Connection.prototype.clearConnectTimer = function() {
    if (this.connectTimer) {
      return clearTimeout(this.connectTimer);
    }
  };

  Connection.prototype.transitionTo = function(newState) {
    var _ref, _ref1;

    if ((_ref = this.state) != null ? _ref.exit : void 0) {
      this.state.exit.apply(this);
    }
    this.debug.log("State change: " + ((_ref1 = this.state) != null ? _ref1.name : void 0) + " -> " + newState.name);
    this.state = newState;
    if (this.state.enter) {
      return this.state.enter.apply(this);
    }
  };

  Connection.prototype.dispatchEvent = function() {
    var args, eventFunction, eventName, _ref;

    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((_ref = this.state) != null ? _ref.events[eventName] : void 0) {
      return eventFunction = this.state.events[eventName].apply(this, args);
    } else {
      throw new Error("No event '" + eventName + "' in state '" + this.state.name + "'");
    }
  };

  Connection.prototype.socketError = function(error) {
    var message;

    message = "connection to " + this.config.server + ":" + this.config.options.port + " - failed " + error;
    this.debug.log(message);
    if (this.state === this.STATE.CONNECTING) {
      this.emit('connect', message);
    } else {
      this.emit('errorMessage', message);
    }
    return this.dispatchEvent('socketError', error);
  };

  Connection.prototype.socketConnect = function() {
    this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
    return this.dispatchEvent('socketConnect');
  };

  Connection.prototype.socketClose = function() {
    this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
    return this.transitionTo(this.STATE.FINAL);
  };

  Connection.prototype.sendPreLogin = function() {
    var payload;

    payload = new PreloginPayload({
      encrypt: this.config.options.encrypt
    });
    this.messageIo.sendMessage(TYPE.PRELOGIN, payload.data);
    return this.debug.payload(function() {
      return payload.toString('  ');
    });
  };

  Connection.prototype.emptyMessageBuffer = function() {
    return this.messageBuffer = new Buffer(0);
  };

  Connection.prototype.addToMessageBuffer = function(data) {
    return this.messageBuffer = Buffer.concat([this.messageBuffer, data]);
  };

  Connection.prototype.processPreLoginResponse = function() {
    var preloginPayload;

    preloginPayload = new PreloginPayload(this.messageBuffer);
    this.debug.payload(function() {
      return preloginPayload.toString('  ');
    });
    if (preloginPayload.encryptionString === 'ON') {
      return this.dispatchEvent('tls');
    } else {
      return this.dispatchEvent('noTls');
    }
  };

  Connection.prototype.sendLogin7Packet = function() {
    var loginData, payload;

    loginData = {
      userName: this.config.userName,
      password: this.config.password,
      database: this.config.options.database,
      appName: this.config.options.appName,
      packetSize: this.config.options.packetSize,
      tdsVersion: this.config.options.tdsVersion
    };
    payload = new Login7Payload(loginData);
    this.messageIo.sendMessage(TYPE.LOGIN7, payload.data);
    return this.debug.payload(function() {
      return payload.toString('  ');
    });
  };

  Connection.prototype.initiateTlsSslHandshake = function() {
    var credentials, _base,
      _this = this;

    (_base = this.config.options.cryptoCredentialsDetails).ciphers || (_base.ciphers = 'RC4-MD5');
    credentials = crypto.createCredentials(this.config.options.cryptoCredentialsDetails);
    this.securePair = tls.createSecurePair(credentials);
    this.securePair.on('secure', function() {
      var cipher;

      cipher = _this.securePair.cleartext.getCipher();
      _this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
      _this.emit('secure', _this.securePair.cleartext);
      _this.messageIo.encryptAllFutureTraffic();
      return _this.dispatchEvent('tlsNegotiated');
    });
    this.securePair.encrypted.on('data', function(data) {
      return _this.messageIo.sendMessage(TYPE.PRELOGIN, data);
    });
    return this.messageIo.tlsNegotiationStarting(this.securePair);
  };

  Connection.prototype.sendDataToTokenStreamParser = function(data) {
    return this.tokenStreamParser.addBuffer(data);
  };

  Connection.prototype.sendInitialSql = function() {
    var payload;

    payload = new SqlBatchPayload(this.getInitialSql(), this.currentTransactionDescriptor());
    return this.messageIo.sendMessage(TYPE.SQL_BATCH, payload.data);
  };

  Connection.prototype.getInitialSql = function() {
    return 'set textsize ' + this.config.options.textsize + 'set quoted_identifier on\nset arithabort off\nset numeric_roundabort off\nset ansi_warnings on\nset ansi_padding on\nset ansi_nulls on\nset concat_null_yields_null on\nset cursor_close_on_commit off\nset implicit_transactions off\nset language us_english\nset dateformat mdy\nset datefirst 7\nset transaction isolation level read committed';
  };

  Connection.prototype.processedInitialSql = function() {
    this.clearConnectTimer();
    return this.emit('connect');
  };

  Connection.prototype.processLogin7Response = function() {
    if (this.loggedIn) {
      return this.dispatchEvent('loggedIn');
    } else {
      this.emit('connect', 'Login failed; one or more errorMessage events should have been emitted');
      return this.dispatchEvent('loginFailed');
    }
  };

  Connection.prototype.execSqlBatch = function(request) {
    return this.makeRequest(request, TYPE.SQL_BATCH, new SqlBatchPayload(request.sqlTextOrProcedure, this.currentTransactionDescriptor()));
  };

  Connection.prototype.execSql = function(request) {
    request.transformIntoExecuteSqlRpc();
    return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor()));
  };

  Connection.prototype.prepare = function(request) {
    request.transformIntoPrepareRpc();
    return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor()));
  };

  Connection.prototype.unprepare = function(request) {
    request.transformIntoUnprepareRpc();
    return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor()));
  };

  Connection.prototype.execute = function(request, parameters) {
    request.transformIntoExecuteRpc(parameters);
    return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor()));
  };

  Connection.prototype.callProcedure = function(request) {
    return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor()));
  };

  Connection.prototype.beginTransaction = function(callback, name, isolationLevel) {
    var request, transaction,
      _this = this;

    name || (name = '');
    isolationLevel || (isolationLevel = this.config.options.isolationLevel);
    transaction = new Transaction(name, isolationLevel);
    this.transactions.push(transaction);
    request = new Request(void 0, function(err) {
      return callback(err, _this.currentTransactionDescriptor());
    });
    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
  };

  Connection.prototype.commitTransaction = function(callback) {
    var request, transaction;

    if (this.transactions.length === 0) {
      throw new Error('No transaction in progress');
    }
    transaction = this.transactions.pop();
    request = new Request(void 0, callback);
    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
  };

  Connection.prototype.rollbackTransaction = function(callback) {
    var request, transaction;

    if (this.transactions.length === 0) {
      throw new Error('No transaction in progress');
    }
    transaction = this.transactions.pop();
    request = new Request(void 0, callback);
    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
  };

  Connection.prototype.makeRequest = function(request, packetType, payload) {
    var message;

    if (this.state !== this.STATE.LOGGED_IN) {
      message = "Invalid state; requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
      this.debug.log(message);
      return request.callback(message);
    } else {
      this.request = request;
      this.request.rowCount = 0;
      this.request.rows = [];
      this.messageIo.sendMessage(packetType, payload.data, this.resetConnectionOnNextRequest);
      this.resetConnectionOnNextRequest = false;
      this.debug.payload(function() {
        return payload.toString('  ');
      });
      return this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
    }
  };

  Connection.prototype.reset = function(callback) {
    var request;

    request = new Request(this.getInitialSql(), function(err, rowCount, rows) {
      return callback(err);
    });
    this.resetConnectionOnNextRequest = true;
    return this.execSqlBatch(request);
  };

  Connection.prototype.currentTransactionDescriptor = function() {
    return this.transactionDescriptors[this.transactionDescriptors.length - 1];
  };

  return Connection;

})(EventEmitter);

module.exports = Connection;
